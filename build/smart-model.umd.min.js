/*! SmartModel v0.5.0 */

!function (e, t) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = t() : typeof define === 'function' && define.amd ? define(t) : (e = typeof globalThis !== 'undefined' ? globalThis : e || self).SmartModel = t()
}(this, function () {
  'use strict'; function e(e) {
    return Array.isArray(e)
  } function t(e) {
    return void 0 === e
  } function r(e) {
    return typeof e === 'function'
  } function n(e) {
    return e && e.toString().startsWith('class')
  } function s(e) {
    return e && (e.prototype instanceof l || e instanceof l)
  } function o(e) {
    return e && e.toString() === '[object Object]'
  } function i(e, t = function () {}) {
    return Object.keys(e).map(t)
  } function c(e) {
    return [].concat([], e)
  } function u(e, t) {
    return t = Object.assign({}, e, t), i(e, (r) => {
      o(e[r]) && o(t[r]) && (t[r] = Object.assign({}, e[r], u(e[r], t[r])))
    }), t
  } class a extends Error {
    constructor(e) {
      super(e.message), Object.assign(this, e)
    }
  } function f(t, r, u, a, f) {
    const p = []

    return f.strict && !i(t || {}).length && p.push({ message: `Property "${r}" can't be set in strict mode`, code: 'strict' }), t.required && f.empty(u) ? (p.push({ message: `Property "${r}" is "required"`, code: 'required' }), p) : t.readonly && !a ? (p.push({ message: `Property "${r}" is "readonly"`, code: 'readonly' }), p) : (void 0 === u || (!t.type || !t.required && f.empty(u) || s(t.type) && o(u) || c(t.type).some((t) => function (t, r) {
      const s = r && r.toString().match(/^\s*function (\w+)/), o = (s ? s[1] : 'object').toLowerCase()

      if (o === 'date' && t instanceof r) {
        return !0
      } if (o === 'array' && e(t)) {
        return !0
      } if (o === 'object') {
        if (n(r) && t instanceof r) {
          return !0
        } if (!n(r) && typeof t === o) {
          return !0
        }
      } else if (typeof t === o) {
        return !0
      }

      return !1
    }(u, t)) || p.push({ message: `Property "${r}" has an invalid type "${typeof u}"`, code: 'type' }), t.rule && i(t.rule, (e) => {
      (0, t.rule[e])(u) && p.push({ message: `Property "${r}" triggers the "${e}" rule error`, code: 'rule:' + e })
    })), p)
  } function p(e = {}, t, r) {
    if (e.type) {
      const n = !!s(e.type) && e.type, i = !!o(e.type) && e.type

      if (n || i) {
        const s = n || l.create(t.normalize('NFD').replace(/[\u0300-\u036f]/g, '').match(/[a-z1-9]+/gi).map((e) => e.charAt(0).toUpperCase() + e.substr(1).toLowerCase()).join(''), i, r)

        return e.type = s, s
      }
    }

    return !1
  }a.throw = function (e, t, r, n, s) {
    const i = t.split(':')[0]

    if (s = s && s.constructor.name, !0 === e.exceptions || o(e.exceptions) && e.exceptions[i]) {
      throw new a({ message: `[${s}] ${r}`, source: s, property: n, code: t })
    }
  }; class l extends class {
    constructor(n, o) {
      return new Proxy(this, { set(c, u, l) {
        const d = n[u] || {}, h = c[u], y = t(h), $ = !(y || (g = l, m = h, JSON.stringify(g) === JSON.stringify(m))); let g, m; const b = p(d, u, o)

        function S(e, r) {
          const s = Reflect.apply(e, c, r || [ u, l, h, n ])

          return t(s) ? l : s
        } let j

        l = S(c.$onBeforeSet), $ && (l = S(c.$onBeforeUpdate)), r(d.transform) && (l = S(d.transform, [ l, n ])), e(j = d.type) && j.length === 1 && s(j[0]) && !t(l) && (l = d.type[0].$hydrate(l), d.type = Array); const w = f(d, u, l, y, o)

        if (w.length) {
          if (!o.exceptions) {
            return !0
          } a.throw(o, w[0].code, w[0].message, u, c)
        }

        return o.strict && !i(d).length || (b && !t(l) && (l = new b(l)), c[u] = l, S(c.$onSet), $ && (S(c.$onUpdate), c.$applySubscribers(u, l))), !0
      }, get(e, o) {
        const c = n[o]; let u = e[o]

        if ([ '$get' ].includes(o)) {
          return function () {
            return function (e) {
              return i(e = Object.assign({}, e), (t) => {
                s(e[t]) && (e[t] = e[t].$get())
              }), e
            }(e)
          }
        } if (!c) {
          return e[o]
        } function a(r, s) {
          const i = Reflect.apply(r, e, s || [ o, u, n ])

          return t(i) ? u : i
        }

        return u = a(e.$onBeforeGet), r(c) && (u = a(c, [ e, n ])), r(c.format) && (u = a(c.format, [ u, n ])), u = a(e.$onGet), u
      }, deleteProperty(e, t) {
        const r = e[t]

        function s(s, o) {
          return Reflect.apply(s, e, o || [ t, r, n ])
        }

        return (n[t] || {}).required && a.throw(o, 'required', `Property "${t}" is "required"`, t, e), s(e.$onBeforeDelete), Reflect.deleteProperty(e, t), s(e.$onDelete), s(e.$onUpdate), e.$applySubscribers(t, r), !0
      } })
    }
  } {
    constructor(e = {}, n = {}, s) {
      super(e, s), i(e, (s) => {
        t(n[s]) && (t(e[s].default) ? r(e[s]) || (this[s] = n[s]) : this[s] = e[s].default)
      }), this.$patch(n)
    }$patch(e) {
      i(e, (t) => {
        this[t] = e[t]
      })
    }$post(e) {
      const n = this.$schema()

      i(n, (o) => {
        t(e[o]) ? t(n[o].default) ? r(n[o]) || (this[o] = e[o]) : this[o] = n[o].default : s(this[o]) ? this[o].$put(e[o]) : this[o] = e[o]
      }), i(e, (t) => {
        this[t] = e[t]
      })
    }$put(e) {
      return this.$put(e)
    }$delete(e) {
      c(e).forEach((e) => {
        Reflect.deleteProperty(this, e)
      })
    }$subscribe(e) {
      return this.$subscribers().push(e), () => {
        this.$subscribers(e)
      }
    }
  }

  return l.settings = { empty: (e) => e === '' || e === null || t(e), strict: !1, exceptions: { readonly: !1, required: !0, rule: !0, strict: !1, type: !0 }, methods: { $onBeforeGet: () => {}, $onBeforeSet: () => {}, $onBeforeUpdate: () => {}, $onDelete: () => {}, $onGet: () => {}, $onBeforeDelete: () => {}, $onSet: () => {}, $onUpdate: () => {} } }, l.create = function (t, r, n) {
    let s = []

    n = u(l.settings, n); const o = { [t]: class extends l {
      constructor(e) {
        super(r, e, n)
      }$schema() {
        return r
      }$subscribers(e) {
        return e && (s = s.filter((t) => t !== e)), s
      }$applySubscribers(e, t) {
        i(s, (r) => {
          Reflect.apply(s[r], this, [ e, t, this ])
        })
      }
    } }[t]

    return o.$check = function (e = {}, t) {
      const s = {}

      return i(r, (o) => {
        let i; const u = e[o], a = r[o], l = p(a, o, n)

        l && (i = l.$check(u, t)); let d = f(a, o, u, !1, n)

        i ? s[o] = i : d.length && (t && (d = d.filter((e) => !c(t).includes(e.code))), d.length && (s[o] = d))
      }), !!i(s).length && s
    }, o.$hydrate = function (t) {
      return e(t) ? t.map((e) => new o(e)) : new o(t)
    }, Object.assign(o.prototype, n.methods), o
  }, l
})
