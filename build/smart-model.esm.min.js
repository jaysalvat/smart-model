/*! SmartModel v0.5.0 */

function e(e) {
  return Array.isArray(e)
} function t(e) {
  return void 0 === e
} function r(e) {
  return typeof e === 'function'
} function n(e) {
  return e && e.toString().startsWith('class')
} function s(e) {
  return e && (e.prototype instanceof l || e instanceof l)
} function o(e) {
  return e && e.toString() === '[object Object]'
} function c(e, t = function () {}) {
  return Object.keys(e).map(t)
} function i(e) {
  return [].concat([], e)
} function u(e, t) {
  return t = Object.assign({}, e, t), c(e, (r) => {
    o(e[r]) && o(t[r]) && (t[r] = Object.assign({}, e[r], u(e[r], t[r])))
  }), t
} class a extends Error {
  constructor(e) {
    super(e.message), Object.assign(this, e)
  }
} function p(t, r, u, a, p) {
  const f = []

  return p.strict && !c(t || {}).length && f.push({ message: `Property "${r}" can't be set in strict mode`, code: 'strict' }), t.required && p.empty(u) ? (f.push({ message: `Property "${r}" is "required"`, code: 'required' }), f) : t.readonly && !a ? (f.push({ message: `Property "${r}" is "readonly"`, code: 'readonly' }), f) : (void 0 === u || (!t.type || !t.required && p.empty(u) || s(t.type) && o(u) || i(t.type).some((t) => function (t, r) {
    const s = r && r.toString().match(/^\s*function (\w+)/), o = (s ? s[1] : 'object').toLowerCase()

    if (o === 'date' && t instanceof r) {
      return !0
    } if (o === 'array' && e(t)) {
      return !0
    } if (o === 'object') {
      if (n(r) && t instanceof r) {
        return !0
      } if (!n(r) && typeof t === o) {
        return !0
      }
    } else if (typeof t === o) {
      return !0
    }

    return !1
  }(u, t)) || f.push({ message: `Property "${r}" has an invalid type "${typeof u}"`, code: 'type' }), t.rule && c(t.rule, (e) => {
    (0, t.rule[e])(u) && f.push({ message: `Property "${r}" triggers the "${e}" rule error`, code: 'rule:' + e })
  })), f)
} function f(e = {}, t, r) {
  if (e.type) {
    const n = !!s(e.type) && e.type, c = !!o(e.type) && e.type

    if (n || c) {
      const s = n || l.create(t.normalize('NFD').replace(/[\u0300-\u036f]/g, '').match(/[a-z1-9]+/gi).map((e) => e.charAt(0).toUpperCase() + e.substr(1).toLowerCase()).join(''), c, r)

      return e.type = s, s
    }
  }

  return !1
}a.throw = function (e, t, r, n, s) {
  const c = t.split(':')[0]

  if (s = s && s.constructor.name, !0 === e.exceptions || o(e.exceptions) && e.exceptions[c]) {
    throw new a({ message: `[${s}] ${r}`, source: s, property: n, code: t })
  }
}; class l extends class {
  constructor(n, o) {
    return new Proxy(this, { set(i, u, l) {
      const h = n[u] || {}, y = i[u], $ = t(y), d = !($ || (g = l, m = y, JSON.stringify(g) === JSON.stringify(m))); let g, m; const b = f(h, u, o)

      function w(e, r) {
        const s = Reflect.apply(e, i, r || [ u, l, y, n ])

        return t(s) ? l : s
      } let S

      l = w(i.$onBeforeSet), d && (l = w(i.$onBeforeUpdate)), r(h.transform) && (l = w(h.transform, [ l, n ])), e(S = h.type) && S.length === 1 && s(S[0]) && !t(l) && (l = h.type[0].$hydrate(l), h.type = Array); const j = p(h, u, l, $, o)

      if (j.length) {
        if (!o.exceptions) {
          return !0
        } a.throw(o, j[0].code, j[0].message, u, i)
      }

      return o.strict && !c(h).length || (b && !t(l) && (l = new b(l)), i[u] = l, w(i.$onSet), d && (w(i.$onUpdate), i.$applySubscribers(u, l))), !0
    }, get(e, o) {
      const i = n[o]; let u = e[o]

      if ([ '$get' ].includes(o)) {
        return function () {
          return function (e) {
            return c(e = Object.assign({}, e), (t) => {
              s(e[t]) && (e[t] = e[t].$get())
            }), e
          }(e)
        }
      } if (!i) {
        return e[o]
      } function a(r, s) {
        const c = Reflect.apply(r, e, s || [ o, u, n ])

        return t(c) ? u : c
      }

      return u = a(e.$onBeforeGet), r(i) && (u = a(i, [ e, n ])), r(i.format) && (u = a(i.format, [ u, n ])), u = a(e.$onGet), u
    }, deleteProperty(e, t) {
      const r = e[t]

      function s(s, o) {
        return Reflect.apply(s, e, o || [ t, r, n ])
      }

      return (n[t] || {}).required && a.throw(o, 'required', `Property "${t}" is "required"`, t, e), s(e.$onBeforeDelete), Reflect.deleteProperty(e, t), s(e.$onDelete), s(e.$onUpdate), e.$applySubscribers(t, r), !0
    } })
  }
} {
  constructor(e = {}, n = {}, s) {
    super(e, s), c(e, (s) => {
      t(n[s]) && (t(e[s].default) ? r(e[s]) || (this[s] = n[s]) : this[s] = e[s].default)
    }), this.$patch(n)
  }$patch(e) {
    c(e, (t) => {
      this[t] = e[t]
    })
  }$post(e) {
    const n = this.$schema()

    c(n, (o) => {
      t(e[o]) ? t(n[o].default) ? r(n[o]) || (this[o] = e[o]) : this[o] = n[o].default : s(this[o]) ? this[o].$put(e[o]) : this[o] = e[o]
    }), c(e, (t) => {
      this[t] = e[t]
    })
  }$put(e) {
    return this.$put(e)
  }$delete(e) {
    i(e).forEach((e) => {
      Reflect.deleteProperty(this, e)
    })
  }$subscribe(e) {
    return this.$subscribers().push(e), () => {
      this.$subscribers(e)
    }
  }
}l.settings = { empty: (e) => e === '' || e === null || t(e), strict: !1, exceptions: { readonly: !1, required: !0, rule: !0, strict: !1, type: !0 }, methods: { $onBeforeGet: () => {}, $onBeforeSet: () => {}, $onBeforeUpdate: () => {}, $onDelete: () => {}, $onGet: () => {}, $onBeforeDelete: () => {}, $onSet: () => {}, $onUpdate: () => {} } }, l.create = function (t, r, n) {
  let s = []

  n = u(l.settings, n); const o = { [t]: class extends l {
    constructor(e) {
      super(r, e, n)
    }$schema() {
      return r
    }$subscribers(e) {
      return e && (s = s.filter((t) => t !== e)), s
    }$applySubscribers(e, t) {
      c(s, (r) => {
        Reflect.apply(s[r], this, [ e, t, this ])
      })
    }
  } }[t]

  return o.$check = function (e = {}, t) {
    const s = {}

    return c(r, (o) => {
      let c; const u = e[o], a = r[o], l = f(a, o, n)

      l && (c = l.$check(u, t)); let h = p(a, o, u, !1, n)

      c ? s[o] = c : h.length && (t && (h = h.filter((e) => !i(t).includes(e.code))), h.length && (s[o] = h))
    }), !!c(s).length && s
  }, o.$hydrate = function (t) {
    return e(t) ? t.map((e) => new o(e)) : new o(t)
  }, Object.assign(o.prototype, n.methods), o
}; export default l
