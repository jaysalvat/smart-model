/*! SmartModel v0.6.2 */
"use strict";function isArray(e){return Array.isArray(e)}function isUndef(e){return void 0===e}function isFn(e){return"function"==typeof e}function isEqual(e,t){return JSON.stringify(e)===JSON.stringify(t)}function isClass(e){return e&&e.toString().startsWith("class")}function isSmartModel(e){return e&&(e.prototype instanceof SmartModel||e instanceof SmartModel)}function isPlainObject(e){return e&&"[object Object]"===e.toString()}function isTypeArrayOfSmartModels(e){return isArray(e)&&1===e.length&&isSmartModel(e[0])}function keys(e,t=function(){}){return Object.keys(e).map((r=>t(r,e[r])))}function toArray(e){return[].concat([],e)}function merge(e,t){return t=Object.assign({},e,t),keys(e,(r=>{isPlainObject(e[r])&&isPlainObject(t[r])&&(t[r]=Object.assign({},e[r],merge(e[r],t[r])))})),t}function eject(e){return keys(e=Object.assign({},e),(t=>{isSmartModel(e[t])&&(e[t]=e[t].$get())})),e}function pascalCase(e){return e.normalize("NFD").replace(/[\u0300-\u036f]/g,"").match(/[a-z1-9]+/gi).map((e=>e.charAt(0).toUpperCase()+e.substr(1).toLowerCase())).join("")}function checkType(e,t){const r=t&&t.toString().match(/^\s*function (\w+)/),s=(r?r[1]:"object").toLowerCase();if("date"===s&&e instanceof t)return!0;if("array"===s&&isArray(e))return!0;if("object"===s){if(isClass(t)&&e instanceof t)return!0;if(!isClass(t)&&typeof e===s)return!0}else if(typeof e===s)return!0;return!1}class SmartModelError extends Error{constructor(e){super(e.message),Object.assign(this,e)}}function checkErrors(e,t,r,s,n){const o=[];return n.strict&&!keys(e||{}).length&&o.push({message:`Property "${t}" can't be set in strict mode`,code:"strict"}),e.required&&n.empty(r)?(o.push({message:`Property "${t}" is "required"`,code:"required"}),o):e.readonly&&!s?(o.push({message:`Property "${t}" is "readonly"`,code:"readonly"}),o):(void 0===r||(!e.type||!e.required&&n.empty(r)||isSmartModel(e.type)&&isPlainObject(r)||toArray(e.type).some((e=>checkType(r,e)))||o.push({message:`Property "${t}" has an invalid type "${typeof r}"`,code:"type"}),e.rule&&keys(e.rule,((e,s)=>{s(r)&&o.push({message:`Property "${t}" triggers the "${e}" rule error`,code:"rule:"+e})}))),o)}function createNested(e={},t,r){if(e.type){const s=!!isSmartModel(e.type)&&e.type,n=!!isPlainObject(e.type)&&e.type;if(s||n){const o=s||SmartModel.create(pascalCase(t),n,r);return e.type=o,o}}return!1}SmartModelError.throw=function(e,t,r,s,n){const o=t.split(":")[0];if(n=n&&n.constructor.name,!0===e.exceptions||isPlainObject(e.exceptions)&&e.exceptions[o])throw new SmartModelError({message:`[${n}] ${r}`,source:n,property:s,code:t})};class SmartModelProxy{constructor(e,t){return new Proxy(this,{set(r,s,n){const o=e[s]||{},i=r[s],c=isUndef(i),a=!c&&!isEqual(n,i),u=createNested(o,s,t);function l(t,o){const c=Reflect.apply(t,r,o||[s,n,i,e]);return isUndef(c)?n:c}n=l(r.$onBeforeSet),a&&(n=l(r.$onBeforeUpdate)),isFn(o.transform)&&(n=l(o.transform,[n,e])),isTypeArrayOfSmartModels(o.type)&&!isUndef(n)&&(n=o.type[0].$hydrate(n),o.type=Array);const p=checkErrors(o,s,n,c,t);if(p.length){if(!t.exceptions)return!0;SmartModelError.throw(t,p[0].code,p[0].message,s,r)}return t.strict&&!keys(o).length||(u&&!isUndef(n)&&(n=new u(n)),r[s]=n,l(r.$onSet),a&&(l(r.$onUpdate),r.$applySubscribers(s,n))),!0},get(t,r){const s=e[r];let n=t[r];if(["$get"].includes(r))return function(){return eject(t)};if(!s)return t[r];function o(s,o){const i=Reflect.apply(s,t,o||[r,n,e]);return isUndef(i)?n:i}return n=o(t.$onBeforeGet),isFn(s)&&(n=o(s,[t,e])),isFn(s.format)&&(n=o(s.format,[n,e])),n=o(t.$onGet),n},deleteProperty(r,s){const n=r[s];function o(t,o){return Reflect.apply(t,r,o||[s,n,e])}return(e[s]||{}).required&&SmartModelError.throw(t,"required",`Property "${s}" is "required"`,s,r),!1===o(r.$onBeforeDelete)||(Reflect.deleteProperty(r,s),o(r.$onDelete),o(r.$onUpdate),r.$applySubscribers(s,n)),!0}})}}class SmartModel extends SmartModelProxy{constructor(e={},t={},r){super(e,r),this.$post(t)}$patch(e){keys(e,(t=>{this[t]=e[t]}))}$post(e){const t=this.$schema();keys(t,((t,r)=>{isUndef(e[t])&&(this[t]=isUndef(r.default)?void 0:r.default)})),keys(this,((e,r)=>{isUndef(t[e]&&isUndef(r))&&this.$delete(e)})),this.$patch(e)}$put(e){return this.$post(e)}$delete(e){toArray(e).forEach((e=>{Reflect.deleteProperty(this,e)}))}$subscribe(e){return this.$subscribers().push(e),()=>{this.$subscribers(e)}}}SmartModel.settings={empty:e=>""===e||null===e||isUndef(e),strict:!1,exceptions:{readonly:!1,required:!0,rule:!0,strict:!1,type:!0},methods:{$onBeforeGet:()=>{},$onBeforeSet:()=>{},$onBeforeUpdate:()=>{},$onDelete:()=>{},$onGet:()=>{},$onBeforeDelete:()=>{},$onSet:()=>{},$onUpdate:()=>{}}},SmartModel.create=function(e,t,r){let s=[];r=merge(SmartModel.settings,r);const n={[e]:class extends SmartModel{constructor(e){super(t,e,r)}$schema(){return t}$subscribers(e){return e&&(s=s.filter((t=>t!==e))),s}$applySubscribers(e,t){keys(s,((r,s)=>{Reflect.apply(s,this,[e,t,this])}))}}}[e];return n.$check=function(e={},s){const n={};return keys(t,((t,o)=>{let i;const c=e[t],a=createNested(o,t,r);a&&(i=a.$check(c,s));let u=checkErrors(o,t,c,!1,r);i?n[t]=i:u.length&&(s&&(u=u.filter((e=>!toArray(s).includes(e.code)))),u.length&&(n[t]=u))})),!!keys(n).length&&n},n.$hydrate=function(e){return isArray(e)?e.map((e=>new n(e))):new n(e)},Object.assign(n.prototype,r.methods),n},module.exports=SmartModel;
